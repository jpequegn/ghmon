# Phase 1 MVP Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build ghmon CLI that imports GitHub following list, fetches activity, and displays digests.

**Architecture:** Go CLI with Cobra, SQLite for storage, GitHub REST API for data. Config stored in ~/.ghmon/config.yaml, database at ~/.ghmon/ghmon.db. Follows blogmon patterns.

**Tech Stack:** Go, Cobra, SQLite (mattn/go-sqlite3), GitHub API, Lipgloss (terminal styling)

---

## Task 1: Project Setup

**Files:**
- Create: `go.mod`
- Create: `main.go`
- Create: `cmd/root.go`

**Step 1: Initialize Go module**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go mod init github.com/julienpequegnot/ghmon
```

**Step 2: Create main.go**

```go
// main.go
package main

import "github.com/julienpequegnot/ghmon/cmd"

func main() {
	cmd.Execute()
}
```

**Step 3: Create cmd/root.go**

```go
// cmd/root.go
package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
	Use:   "ghmon",
	Short: "Monitor GitHub accounts you follow",
	Long:  `ghmon tracks activity from GitHub accounts you follow and generates digests.`,
}

func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}
```

**Step 4: Add dependencies**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go get github.com/spf13/cobra && go get github.com/mattn/go-sqlite3 && go get gopkg.in/yaml.v3 && go get github.com/charmbracelet/lipgloss
```

**Step 5: Build and verify**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go build -o ghmon . && ./ghmon --help
```

Expected: Help message displays

**Step 6: Commit**

```bash
cd /Users/julienpequegnot/Code/ghmon && git add . && git commit -m "feat: project setup with Cobra CLI"
```

---

## Task 2: Config Package

**Files:**
- Create: `internal/config/config.go`
- Create: `internal/config/config_test.go`

**Step 1: Write tests**

```go
// internal/config/config_test.go
package config

import (
	"os"
	"path/filepath"
	"testing"
)

func TestDefaultConfig(t *testing.T) {
	cfg := DefaultConfig()

	if cfg.Digest.DefaultDays != 7 {
		t.Errorf("expected default days 7, got %d", cfg.Digest.DefaultDays)
	}

	if cfg.Fetch.Concurrency != 5 {
		t.Errorf("expected concurrency 5, got %d", cfg.Fetch.Concurrency)
	}
}

func TestConfigDir(t *testing.T) {
	dir := ConfigDir()
	if dir == "" {
		t.Error("config dir should not be empty")
	}
}

func TestSaveAndLoad(t *testing.T) {
	tmpDir := t.TempDir()
	origHome := os.Getenv("HOME")
	os.Setenv("HOME", tmpDir)
	defer os.Setenv("HOME", origHome)

	cfg := DefaultConfig()
	cfg.GitHub.Token = "test-token"

	if err := cfg.Save(); err != nil {
		t.Fatalf("failed to save config: %v", err)
	}

	loaded, err := Load()
	if err != nil {
		t.Fatalf("failed to load config: %v", err)
	}

	if loaded.GitHub.Token != "test-token" {
		t.Errorf("expected token 'test-token', got '%s'", loaded.GitHub.Token)
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go test ./internal/config/... -v
```

Expected: FAIL - package doesn't exist

**Step 3: Implement config**

```go
// internal/config/config.go
package config

import (
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

type Config struct {
	GitHub GitHubConfig `yaml:"github"`
	APIs   APIConfig    `yaml:"apis"`
	Fetch  FetchConfig  `yaml:"fetch"`
	Digest DigestConfig `yaml:"digest"`
}

type GitHubConfig struct {
	Token string `yaml:"token"`
}

type APIConfig struct {
	LLMProvider string `yaml:"llm_provider"`
	LLMModel    string `yaml:"llm_model"`
}

type FetchConfig struct {
	Concurrency    int `yaml:"concurrency"`
	TimeoutSeconds int `yaml:"timeout_seconds"`
}

type DigestConfig struct {
	DefaultDays int `yaml:"default_days"`
}

func DefaultConfig() *Config {
	return &Config{
		GitHub: GitHubConfig{
			Token: "",
		},
		APIs: APIConfig{
			LLMProvider: "ollama",
			LLMModel:    "llama3.2",
		},
		Fetch: FetchConfig{
			Concurrency:    5,
			TimeoutSeconds: 30,
		},
		Digest: DigestConfig{
			DefaultDays: 7,
		},
	}
}

func ConfigDir() string {
	home, _ := os.UserHomeDir()
	return filepath.Join(home, ".ghmon")
}

func ConfigPath() string {
	return filepath.Join(ConfigDir(), "config.yaml")
}

func DBPath() string {
	return filepath.Join(ConfigDir(), "ghmon.db")
}

func (c *Config) Save() error {
	if err := os.MkdirAll(ConfigDir(), 0755); err != nil {
		return err
	}

	data, err := yaml.Marshal(c)
	if err != nil {
		return err
	}

	return os.WriteFile(ConfigPath(), data, 0600)
}

func Load() (*Config, error) {
	data, err := os.ReadFile(ConfigPath())
	if err != nil {
		return nil, err
	}

	var cfg Config
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		return nil, err
	}

	return &cfg, nil
}

func Exists() bool {
	_, err := os.Stat(ConfigPath())
	return err == nil
}
```

**Step 4: Run tests**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go test ./internal/config/... -v
```

Expected: PASS

**Step 5: Commit**

```bash
cd /Users/julienpequegnot/Code/ghmon && git add . && git commit -m "feat: add config package"
```

---

## Task 3: Database Package

**Files:**
- Create: `internal/database/database.go`
- Create: `internal/database/database_test.go`

**Step 1: Write tests**

```go
// internal/database/database_test.go
package database

import (
	"os"
	"path/filepath"
	"testing"
)

func TestNewDB(t *testing.T) {
	tmpDir := t.TempDir()
	dbPath := filepath.Join(tmpDir, "test.db")

	db, err := New(dbPath)
	if err != nil {
		t.Fatalf("failed to create database: %v", err)
	}
	defer db.Close()

	if _, err := os.Stat(dbPath); os.IsNotExist(err) {
		t.Error("database file was not created")
	}
}

func TestInitSchema(t *testing.T) {
	tmpDir := t.TempDir()
	dbPath := filepath.Join(tmpDir, "test.db")

	db, err := New(dbPath)
	if err != nil {
		t.Fatalf("failed to create database: %v", err)
	}
	defer db.Close()

	tables := []string{"accounts", "commits", "repos", "stars", "digests"}
	for _, table := range tables {
		rows, err := db.conn.Query("SELECT 1 FROM " + table + " LIMIT 1")
		if err != nil {
			t.Errorf("table %s does not exist: %v", table, err)
			continue
		}
		rows.Close()
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go test ./internal/database/... -v
```

Expected: FAIL - package doesn't exist

**Step 3: Implement database**

```go
// internal/database/database.go
package database

import (
	"database/sql"
	"path/filepath"

	_ "github.com/mattn/go-sqlite3"
)

type DB struct {
	conn *sql.DB
}

func New(dbPath string) (*DB, error) {
	conn, err := sql.Open("sqlite3", dbPath)
	if err != nil {
		return nil, err
	}

	db := &DB{conn: conn}
	if err := db.initSchema(); err != nil {
		conn.Close()
		return nil, err
	}

	return db, nil
}

func (db *DB) Close() error {
	return db.conn.Close()
}

func (db *DB) Exec(query string, args ...interface{}) (sql.Result, error) {
	return db.conn.Exec(query, args...)
}

func (db *DB) Query(query string, args ...interface{}) (*sql.Rows, error) {
	return db.conn.Query(query, args...)
}

func (db *DB) QueryRow(query string, args ...interface{}) *sql.Row {
	return db.conn.QueryRow(query, args...)
}

func (db *DB) initSchema() error {
	schema := `
	CREATE TABLE IF NOT EXISTS accounts (
		id INTEGER PRIMARY KEY,
		username TEXT UNIQUE NOT NULL,
		name TEXT,
		avatar_url TEXT,
		bio TEXT,
		followers INTEGER DEFAULT 0,
		following INTEGER DEFAULT 0,
		added_at DATETIME DEFAULT CURRENT_TIMESTAMP,
		last_fetched DATETIME
	);

	CREATE TABLE IF NOT EXISTS commits (
		id INTEGER PRIMARY KEY,
		account_id INTEGER NOT NULL,
		repo_name TEXT NOT NULL,
		sha TEXT NOT NULL,
		message TEXT,
		committed_at DATETIME,
		fetched_at DATETIME DEFAULT CURRENT_TIMESTAMP,
		FOREIGN KEY (account_id) REFERENCES accounts(id),
		UNIQUE(account_id, sha)
	);

	CREATE TABLE IF NOT EXISTS repos (
		id INTEGER PRIMARY KEY,
		account_id INTEGER NOT NULL,
		name TEXT NOT NULL,
		full_name TEXT NOT NULL,
		description TEXT,
		language TEXT,
		stars INTEGER DEFAULT 0,
		created_at DATETIME,
		fetched_at DATETIME DEFAULT CURRENT_TIMESTAMP,
		FOREIGN KEY (account_id) REFERENCES accounts(id),
		UNIQUE(account_id, full_name)
	);

	CREATE TABLE IF NOT EXISTS stars (
		id INTEGER PRIMARY KEY,
		account_id INTEGER NOT NULL,
		repo_full_name TEXT NOT NULL,
		repo_description TEXT,
		repo_language TEXT,
		repo_stars INTEGER DEFAULT 0,
		starred_at DATETIME,
		fetched_at DATETIME DEFAULT CURRENT_TIMESTAMP,
		FOREIGN KEY (account_id) REFERENCES accounts(id),
		UNIQUE(account_id, repo_full_name)
	);

	CREATE TABLE IF NOT EXISTS digests (
		id INTEGER PRIMARY KEY,
		period_start DATETIME NOT NULL,
		period_end DATETIME NOT NULL,
		content TEXT,
		smart_analysis TEXT,
		created_at DATETIME DEFAULT CURRENT_TIMESTAMP
	);

	CREATE INDEX IF NOT EXISTS idx_commits_account ON commits(account_id);
	CREATE INDEX IF NOT EXISTS idx_commits_date ON commits(committed_at);
	CREATE INDEX IF NOT EXISTS idx_repos_account ON repos(account_id);
	CREATE INDEX IF NOT EXISTS idx_repos_created ON repos(created_at);
	CREATE INDEX IF NOT EXISTS idx_stars_account ON stars(account_id);
	CREATE INDEX IF NOT EXISTS idx_stars_date ON stars(starred_at);
	`

	_, err := db.conn.Exec(schema)
	return err
}
```

**Step 4: Run tests**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go test ./internal/database/... -v
```

Expected: PASS

**Step 5: Commit**

```bash
cd /Users/julienpequegnot/Code/ghmon && git add . && git commit -m "feat: add database package with schema"
```

---

## Task 4: Account Repository

**Files:**
- Create: `internal/account/repository.go`
- Create: `internal/account/repository_test.go`

**Step 1: Write tests**

```go
// internal/account/repository_test.go
package account

import (
	"path/filepath"
	"testing"

	"github.com/julienpequegnot/ghmon/internal/database"
)

func setupTestDB(t *testing.T) *database.DB {
	tmpDir := t.TempDir()
	db, err := database.New(filepath.Join(tmpDir, "test.db"))
	if err != nil {
		t.Fatalf("failed to create test database: %v", err)
	}
	return db
}

func TestAddAccount(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()

	repo := NewRepository(db)

	acc, err := repo.Add("torvalds", "Linus Torvalds", "", "")
	if err != nil {
		t.Fatalf("failed to add account: %v", err)
	}

	if acc.Username != "torvalds" {
		t.Errorf("expected username 'torvalds', got '%s'", acc.Username)
	}
}

func TestAddDuplicateAccount(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()

	repo := NewRepository(db)

	_, err := repo.Add("torvalds", "Linus Torvalds", "", "")
	if err != nil {
		t.Fatalf("failed to add account: %v", err)
	}

	_, err = repo.Add("torvalds", "Linus Torvalds", "", "")
	if err == nil {
		t.Error("expected error when adding duplicate account")
	}
}

func TestListAccounts(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()

	repo := NewRepository(db)

	repo.Add("torvalds", "Linus", "", "")
	repo.Add("antirez", "Salvatore", "", "")

	accounts, err := repo.List()
	if err != nil {
		t.Fatalf("failed to list accounts: %v", err)
	}

	if len(accounts) != 2 {
		t.Errorf("expected 2 accounts, got %d", len(accounts))
	}
}

func TestRemoveAccount(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()

	repo := NewRepository(db)

	repo.Add("torvalds", "Linus", "", "")

	err := repo.Remove("torvalds")
	if err != nil {
		t.Fatalf("failed to remove account: %v", err)
	}

	accounts, _ := repo.List()
	if len(accounts) != 0 {
		t.Errorf("expected 0 accounts after removal, got %d", len(accounts))
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go test ./internal/account/... -v
```

Expected: FAIL - package doesn't exist

**Step 3: Implement repository**

```go
// internal/account/repository.go
package account

import (
	"fmt"
	"time"

	"github.com/julienpequegnot/ghmon/internal/database"
)

type Account struct {
	ID          int64
	Username    string
	Name        string
	AvatarURL   string
	Bio         string
	Followers   int
	Following   int
	AddedAt     time.Time
	LastFetched *time.Time
}

type Repository struct {
	db *database.DB
}

func NewRepository(db *database.DB) *Repository {
	return &Repository{db: db}
}

func (r *Repository) Add(username, name, avatarURL, bio string) (*Account, error) {
	result, err := r.db.Exec(
		`INSERT INTO accounts (username, name, avatar_url, bio) VALUES (?, ?, ?, ?)`,
		username, name, avatarURL, bio,
	)
	if err != nil {
		return nil, fmt.Errorf("account already exists or error: %w", err)
	}

	id, _ := result.LastInsertId()
	return &Account{
		ID:       id,
		Username: username,
		Name:     name,
	}, nil
}

func (r *Repository) Remove(username string) error {
	// First get account ID
	var id int64
	err := r.db.QueryRow("SELECT id FROM accounts WHERE username = ?", username).Scan(&id)
	if err != nil {
		return fmt.Errorf("account not found: %w", err)
	}

	// Delete related data
	r.db.Exec("DELETE FROM commits WHERE account_id = ?", id)
	r.db.Exec("DELETE FROM repos WHERE account_id = ?", id)
	r.db.Exec("DELETE FROM stars WHERE account_id = ?", id)

	// Delete account
	_, err = r.db.Exec("DELETE FROM accounts WHERE id = ?", id)
	return err
}

func (r *Repository) List() ([]Account, error) {
	rows, err := r.db.Query(`
		SELECT id, username, name, avatar_url, bio, followers, following, added_at, last_fetched
		FROM accounts ORDER BY username
	`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var accounts []Account
	for rows.Next() {
		var a Account
		var lastFetched *time.Time
		if err := rows.Scan(&a.ID, &a.Username, &a.Name, &a.AvatarURL, &a.Bio, &a.Followers, &a.Following, &a.AddedAt, &lastFetched); err != nil {
			return nil, err
		}
		a.LastFetched = lastFetched
		accounts = append(accounts, a)
	}
	return accounts, rows.Err()
}

func (r *Repository) Get(username string) (*Account, error) {
	var a Account
	var lastFetched *time.Time
	err := r.db.QueryRow(`
		SELECT id, username, name, avatar_url, bio, followers, following, added_at, last_fetched
		FROM accounts WHERE username = ?
	`, username).Scan(&a.ID, &a.Username, &a.Name, &a.AvatarURL, &a.Bio, &a.Followers, &a.Following, &a.AddedAt, &lastFetched)
	if err != nil {
		return nil, err
	}
	a.LastFetched = lastFetched
	return &a, nil
}

func (r *Repository) GetByID(id int64) (*Account, error) {
	var a Account
	var lastFetched *time.Time
	err := r.db.QueryRow(`
		SELECT id, username, name, avatar_url, bio, followers, following, added_at, last_fetched
		FROM accounts WHERE id = ?
	`, id).Scan(&a.ID, &a.Username, &a.Name, &a.AvatarURL, &a.Bio, &a.Followers, &a.Following, &a.AddedAt, &lastFetched)
	if err != nil {
		return nil, err
	}
	a.LastFetched = lastFetched
	return &a, nil
}

func (r *Repository) UpdateLastFetched(id int64) error {
	_, err := r.db.Exec("UPDATE accounts SET last_fetched = CURRENT_TIMESTAMP WHERE id = ?", id)
	return err
}

func (r *Repository) Exists(username string) bool {
	var count int
	r.db.QueryRow("SELECT COUNT(*) FROM accounts WHERE username = ?", username).Scan(&count)
	return count > 0
}

func (r *Repository) Count() int {
	var count int
	r.db.QueryRow("SELECT COUNT(*) FROM accounts").Scan(&count)
	return count
}
```

**Step 4: Run tests**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go test ./internal/account/... -v
```

Expected: PASS

**Step 5: Commit**

```bash
cd /Users/julienpequegnot/Code/ghmon && git add . && git commit -m "feat: add account repository"
```

---

## Task 5: Init Command

**Files:**
- Create: `cmd/init.go`

**Step 1: Create init command**

```go
// cmd/init.go
package cmd

import (
	"bufio"
	"fmt"
	"os"
	"strings"

	"github.com/julienpequegnot/ghmon/internal/config"
	"github.com/julienpequegnot/ghmon/internal/database"
	"github.com/spf13/cobra"
)

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize ghmon configuration",
	Long:  `Creates the config file and database for ghmon.`,
	RunE:  runInit,
}

func init() {
	rootCmd.AddCommand(initCmd)
}

func runInit(cmd *cobra.Command, args []string) error {
	if config.Exists() {
		fmt.Println("ghmon is already initialized.")
		fmt.Printf("Config: %s\n", config.ConfigPath())
		fmt.Printf("Database: %s\n", config.DBPath())
		return nil
	}

	fmt.Println("Initializing ghmon...")

	// Prompt for GitHub token
	reader := bufio.NewReader(os.Stdin)
	fmt.Print("Enter your GitHub Personal Access Token (or press Enter to skip): ")
	token, _ := reader.ReadString('\n')
	token = strings.TrimSpace(token)

	cfg := config.DefaultConfig()
	cfg.GitHub.Token = token

	if err := cfg.Save(); err != nil {
		return fmt.Errorf("failed to save config: %w", err)
	}
	fmt.Printf("Created config: %s\n", config.ConfigPath())

	// Initialize database
	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to create database: %w", err)
	}
	db.Close()
	fmt.Printf("Created database: %s\n", config.DBPath())

	fmt.Println("\nghmon initialized successfully!")
	if token == "" {
		fmt.Println("\nNote: No GitHub token set. Run 'ghmon sync' after adding your token to config.")
		fmt.Println("Create a token at: https://github.com/settings/tokens")
	} else {
		fmt.Println("\nRun 'ghmon sync' to import accounts you follow.")
	}

	return nil
}
```

**Step 2: Build and test**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go build -o ghmon . && ./ghmon init --help
```

Expected: Help message displays

**Step 3: Commit**

```bash
cd /Users/julienpequegnot/Code/ghmon && git add . && git commit -m "feat: add init command"
```

---

## Task 6: GitHub API Client

**Files:**
- Create: `internal/github/client.go`
- Create: `internal/github/client_test.go`

**Step 1: Write tests**

```go
// internal/github/client_test.go
package github

import (
	"testing"
)

func TestNewClient(t *testing.T) {
	client := NewClient("test-token")
	if client == nil {
		t.Error("expected non-nil client")
	}
}

func TestParseEventsJSON(t *testing.T) {
	// Test parsing of event JSON structure
	jsonData := `[{
		"type": "PushEvent",
		"repo": {"name": "user/repo"},
		"payload": {"commits": [{"sha": "abc123", "message": "test commit"}]},
		"created_at": "2024-12-30T10:00:00Z"
	}]`

	events, err := parseEvents([]byte(jsonData))
	if err != nil {
		t.Fatalf("failed to parse events: %v", err)
	}

	if len(events) != 1 {
		t.Errorf("expected 1 event, got %d", len(events))
	}

	if events[0].Type != "PushEvent" {
		t.Errorf("expected PushEvent, got %s", events[0].Type)
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go test ./internal/github/... -v
```

Expected: FAIL - package doesn't exist

**Step 3: Implement client**

```go
// internal/github/client.go
package github

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"
)

const baseURL = "https://api.github.com"

type Client struct {
	token      string
	httpClient *http.Client
}

type User struct {
	Login     string `json:"login"`
	Name      string `json:"name"`
	AvatarURL string `json:"avatar_url"`
	Bio       string `json:"bio"`
	Followers int    `json:"followers"`
	Following int    `json:"following"`
}

type Event struct {
	Type      string          `json:"type"`
	Repo      EventRepo       `json:"repo"`
	Payload   json.RawMessage `json:"payload"`
	CreatedAt time.Time       `json:"created_at"`
}

type EventRepo struct {
	Name string `json:"name"`
}

type PushPayload struct {
	Commits []Commit `json:"commits"`
}

type Commit struct {
	SHA     string `json:"sha"`
	Message string `json:"message"`
}

type CreatePayload struct {
	RefType string `json:"ref_type"`
}

type StarredRepo struct {
	FullName    string    `json:"full_name"`
	Description string    `json:"description"`
	Language    string    `json:"language"`
	Stars       int       `json:"stargazers_count"`
	StarredAt   time.Time `json:"starred_at"`
}

type Repo struct {
	Name        string    `json:"name"`
	FullName    string    `json:"full_name"`
	Description string    `json:"description"`
	Language    string    `json:"language"`
	Stars       int       `json:"stargazers_count"`
	CreatedAt   time.Time `json:"created_at"`
}

func NewClient(token string) *Client {
	return &Client{
		token: token,
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
}

func (c *Client) doRequest(url string) ([]byte, error) {
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Accept", "application/vnd.github+json")
	if c.token != "" {
		req.Header.Set("Authorization", "Bearer "+c.token)
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("GitHub API error: %s", resp.Status)
	}

	return io.ReadAll(resp.Body)
}

func (c *Client) GetFollowing() ([]User, error) {
	var allUsers []User
	page := 1

	for {
		url := fmt.Sprintf("%s/user/following?per_page=100&page=%d", baseURL, page)
		data, err := c.doRequest(url)
		if err != nil {
			return nil, err
		}

		var users []User
		if err := json.Unmarshal(data, &users); err != nil {
			return nil, err
		}

		if len(users) == 0 {
			break
		}

		allUsers = append(allUsers, users...)
		page++
	}

	return allUsers, nil
}

func (c *Client) GetUser(username string) (*User, error) {
	url := fmt.Sprintf("%s/users/%s", baseURL, username)
	data, err := c.doRequest(url)
	if err != nil {
		return nil, err
	}

	var user User
	if err := json.Unmarshal(data, &user); err != nil {
		return nil, err
	}

	return &user, nil
}

func (c *Client) GetUserEvents(username string) ([]Event, error) {
	url := fmt.Sprintf("%s/users/%s/events/public?per_page=100", baseURL, username)
	data, err := c.doRequest(url)
	if err != nil {
		return nil, err
	}

	return parseEvents(data)
}

func parseEvents(data []byte) ([]Event, error) {
	var events []Event
	if err := json.Unmarshal(data, &events); err != nil {
		return nil, err
	}
	return events, nil
}

func (c *Client) GetUserStarred(username string) ([]StarredRepo, error) {
	url := fmt.Sprintf("%s/users/%s/starred?per_page=100", baseURL, username)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	// Request starred_at timestamp
	req.Header.Set("Accept", "application/vnd.github.star+json")
	if c.token != "" {
		req.Header.Set("Authorization", "Bearer "+c.token)
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("GitHub API error: %s", resp.Status)
	}

	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	// Parse starred repos with timestamps
	var starResponse []struct {
		StarredAt time.Time `json:"starred_at"`
		Repo      Repo      `json:"repo"`
	}

	if err := json.Unmarshal(data, &starResponse); err != nil {
		return nil, err
	}

	var repos []StarredRepo
	for _, s := range starResponse {
		repos = append(repos, StarredRepo{
			FullName:    s.Repo.FullName,
			Description: s.Repo.Description,
			Language:    s.Repo.Language,
			Stars:       s.Repo.Stars,
			StarredAt:   s.StarredAt,
		})
	}

	return repos, nil
}

func (c *Client) GetUserRepos(username string) ([]Repo, error) {
	url := fmt.Sprintf("%s/users/%s/repos?per_page=100&sort=created&direction=desc", baseURL, username)
	data, err := c.doRequest(url)
	if err != nil {
		return nil, err
	}

	var repos []Repo
	if err := json.Unmarshal(data, &repos); err != nil {
		return nil, err
	}

	return repos, nil
}

// ParsePushPayload extracts commits from a PushEvent payload
func ParsePushPayload(payload json.RawMessage) (*PushPayload, error) {
	var p PushPayload
	if err := json.Unmarshal(payload, &p); err != nil {
		return nil, err
	}
	return &p, nil
}

// ParseCreatePayload extracts ref_type from a CreateEvent payload
func ParseCreatePayload(payload json.RawMessage) (*CreatePayload, error) {
	var p CreatePayload
	if err := json.Unmarshal(payload, &p); err != nil {
		return nil, err
	}
	return &p, nil
}
```

**Step 4: Run tests**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go test ./internal/github/... -v
```

Expected: PASS

**Step 5: Commit**

```bash
cd /Users/julienpequegnot/Code/ghmon && git add . && git commit -m "feat: add GitHub API client"
```

---

## Task 7: Sync Command

**Files:**
- Create: `cmd/sync.go`

**Step 1: Create sync command**

```go
// cmd/sync.go
package cmd

import (
	"fmt"

	"github.com/julienpequegnot/ghmon/internal/account"
	"github.com/julienpequegnot/ghmon/internal/config"
	"github.com/julienpequegnot/ghmon/internal/database"
	"github.com/julienpequegnot/ghmon/internal/github"
	"github.com/spf13/cobra"
)

var syncCmd = &cobra.Command{
	Use:   "sync",
	Short: "Import accounts from GitHub following",
	Long:  `Syncs your monitored accounts with your GitHub following list.`,
	RunE:  runSync,
}

func init() {
	rootCmd.AddCommand(syncCmd)
}

func runSync(cmd *cobra.Command, args []string) error {
	cfg, err := config.Load()
	if err != nil {
		return fmt.Errorf("failed to load config (run 'ghmon init' first): %w", err)
	}

	if cfg.GitHub.Token == "" {
		return fmt.Errorf("GitHub token not set. Add your token to %s", config.ConfigPath())
	}

	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to open database: %w", err)
	}
	defer db.Close()

	fmt.Println("Fetching your GitHub following list...")

	client := github.NewClient(cfg.GitHub.Token)
	following, err := client.GetFollowing()
	if err != nil {
		return fmt.Errorf("failed to fetch following: %w", err)
	}

	fmt.Printf("Found %d accounts you follow.\n", len(following))

	accountRepo := account.NewRepository(db)
	added := 0
	skipped := 0

	for _, user := range following {
		if accountRepo.Exists(user.Login) {
			skipped++
			continue
		}

		_, err := accountRepo.Add(user.Login, user.Name, user.AvatarURL, user.Bio)
		if err != nil {
			fmt.Printf("  Warning: failed to add %s: %v\n", user.Login, err)
			continue
		}
		added++
		fmt.Printf("  + %s\n", user.Login)
	}

	fmt.Printf("\nSync complete: %d added, %d already tracked\n", added, skipped)
	fmt.Println("Run 'ghmon fetch' to pull their activity.")

	return nil
}
```

**Step 2: Build and test**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go build -o ghmon . && ./ghmon sync --help
```

Expected: Help message displays

**Step 3: Commit**

```bash
cd /Users/julienpequegnot/Code/ghmon && git add . && git commit -m "feat: add sync command"
```

---

## Task 8: Add/Remove Commands

**Files:**
- Create: `cmd/add.go`
- Create: `cmd/remove.go`

**Step 1: Create add command**

```go
// cmd/add.go
package cmd

import (
	"fmt"

	"github.com/julienpequegnot/ghmon/internal/account"
	"github.com/julienpequegnot/ghmon/internal/config"
	"github.com/julienpequegnot/ghmon/internal/database"
	"github.com/julienpequegnot/ghmon/internal/github"
	"github.com/spf13/cobra"
)

var addCmd = &cobra.Command{
	Use:   "add <username>",
	Short: "Add a GitHub user to monitor",
	Long:  `Adds a GitHub user to your monitored accounts.`,
	Args:  cobra.ExactArgs(1),
	RunE:  runAdd,
}

func init() {
	rootCmd.AddCommand(addCmd)
}

func runAdd(cmd *cobra.Command, args []string) error {
	username := args[0]

	cfg, err := config.Load()
	if err != nil {
		return fmt.Errorf("failed to load config (run 'ghmon init' first): %w", err)
	}

	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to open database: %w", err)
	}
	defer db.Close()

	accountRepo := account.NewRepository(db)

	if accountRepo.Exists(username) {
		return fmt.Errorf("account '%s' is already being monitored", username)
	}

	// Fetch user info from GitHub
	var name, avatarURL, bio string
	if cfg.GitHub.Token != "" {
		client := github.NewClient(cfg.GitHub.Token)
		user, err := client.GetUser(username)
		if err != nil {
			fmt.Printf("Warning: couldn't fetch user info: %v\n", err)
		} else {
			name = user.Name
			avatarURL = user.AvatarURL
			bio = user.Bio
		}
	}

	_, err = accountRepo.Add(username, name, avatarURL, bio)
	if err != nil {
		return fmt.Errorf("failed to add account: %w", err)
	}

	fmt.Printf("Added %s to monitored accounts.\n", username)
	fmt.Println("Run 'ghmon fetch' to pull their activity.")

	return nil
}
```

**Step 2: Create remove command**

```go
// cmd/remove.go
package cmd

import (
	"fmt"

	"github.com/julienpequegnot/ghmon/internal/account"
	"github.com/julienpequegnot/ghmon/internal/config"
	"github.com/julienpequegnot/ghmon/internal/database"
	"github.com/spf13/cobra"
)

var removeCmd = &cobra.Command{
	Use:   "remove <username>",
	Short: "Remove a GitHub user from monitoring",
	Long:  `Removes a GitHub user from your monitored accounts.`,
	Args:  cobra.ExactArgs(1),
	RunE:  runRemove,
}

func init() {
	rootCmd.AddCommand(removeCmd)
}

func runRemove(cmd *cobra.Command, args []string) error {
	username := args[0]

	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to open database: %w", err)
	}
	defer db.Close()

	accountRepo := account.NewRepository(db)

	if !accountRepo.Exists(username) {
		return fmt.Errorf("account '%s' is not being monitored", username)
	}

	if err := accountRepo.Remove(username); err != nil {
		return fmt.Errorf("failed to remove account: %w", err)
	}

	fmt.Printf("Removed %s from monitored accounts.\n", username)
	return nil
}
```

**Step 3: Build and test**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go build -o ghmon . && ./ghmon add --help && ./ghmon remove --help
```

Expected: Help messages display

**Step 4: Commit**

```bash
cd /Users/julienpequegnot/Code/ghmon && git add . && git commit -m "feat: add add/remove commands"
```

---

## Task 9: Accounts Command

**Files:**
- Create: `cmd/accounts.go`

**Step 1: Create accounts command**

```go
// cmd/accounts.go
package cmd

import (
	"fmt"

	"github.com/charmbracelet/lipgloss"
	"github.com/julienpequegnot/ghmon/internal/account"
	"github.com/julienpequegnot/ghmon/internal/config"
	"github.com/julienpequegnot/ghmon/internal/database"
	"github.com/spf13/cobra"
)

var accountsCmd = &cobra.Command{
	Use:   "accounts",
	Short: "List monitored accounts",
	Long:  `Shows all GitHub accounts being monitored.`,
	RunE:  runAccounts,
}

func init() {
	rootCmd.AddCommand(accountsCmd)
}

func runAccounts(cmd *cobra.Command, args []string) error {
	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to open database (run 'ghmon init' first): %w", err)
	}
	defer db.Close()

	accountRepo := account.NewRepository(db)
	accounts, err := accountRepo.List()
	if err != nil {
		return fmt.Errorf("failed to list accounts: %w", err)
	}

	if len(accounts) == 0 {
		fmt.Println("No accounts monitored yet.")
		fmt.Println("Run 'ghmon sync' to import from your following list, or 'ghmon add <username>' to add manually.")
		return nil
	}

	titleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("205"))
	userStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("39"))
	dimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))

	fmt.Printf("\n%s (%d)\n\n", titleStyle.Render("MONITORED ACCOUNTS"), len(accounts))

	for _, acc := range accounts {
		name := acc.Name
		if name == "" {
			name = acc.Username
		}
		fmt.Printf("  %s", userStyle.Render(acc.Username))
		if acc.Name != "" && acc.Name != acc.Username {
			fmt.Printf(" %s", dimStyle.Render("("+acc.Name+")"))
		}
		fmt.Println()

		if acc.Bio != "" {
			bio := acc.Bio
			if len(bio) > 60 {
				bio = bio[:57] + "..."
			}
			fmt.Printf("    %s\n", dimStyle.Render(bio))
		}
	}

	fmt.Println()
	return nil
}
```

**Step 2: Build and test**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go build -o ghmon . && ./ghmon accounts --help
```

Expected: Help message displays

**Step 3: Commit**

```bash
cd /Users/julienpequegnot/Code/ghmon && git add . && git commit -m "feat: add accounts command"
```

---

## Task 10: Activity Repositories

**Files:**
- Create: `internal/activity/commits.go`
- Create: `internal/activity/repos.go`
- Create: `internal/activity/stars.go`

**Step 1: Create commits repository**

```go
// internal/activity/commits.go
package activity

import (
	"time"

	"github.com/julienpequegnot/ghmon/internal/database"
)

type Commit struct {
	ID          int64
	AccountID   int64
	RepoName    string
	SHA         string
	Message     string
	CommittedAt time.Time
}

type CommitRepository struct {
	db *database.DB
}

func NewCommitRepository(db *database.DB) *CommitRepository {
	return &CommitRepository{db: db}
}

func (r *CommitRepository) Add(accountID int64, repoName, sha, message string, committedAt time.Time) error {
	_, err := r.db.Exec(
		`INSERT OR IGNORE INTO commits (account_id, repo_name, sha, message, committed_at) VALUES (?, ?, ?, ?, ?)`,
		accountID, repoName, sha, message, committedAt,
	)
	return err
}

func (r *CommitRepository) GetForAccount(accountID int64, since time.Time) ([]Commit, error) {
	rows, err := r.db.Query(`
		SELECT id, account_id, repo_name, sha, message, committed_at
		FROM commits
		WHERE account_id = ? AND committed_at >= ?
		ORDER BY committed_at DESC
	`, accountID, since)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var commits []Commit
	for rows.Next() {
		var c Commit
		if err := rows.Scan(&c.ID, &c.AccountID, &c.RepoName, &c.SHA, &c.Message, &c.CommittedAt); err != nil {
			return nil, err
		}
		commits = append(commits, c)
	}
	return commits, rows.Err()
}

func (r *CommitRepository) GetAllSince(since time.Time) ([]Commit, error) {
	rows, err := r.db.Query(`
		SELECT id, account_id, repo_name, sha, message, committed_at
		FROM commits
		WHERE committed_at >= ?
		ORDER BY committed_at DESC
	`, since)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var commits []Commit
	for rows.Next() {
		var c Commit
		if err := rows.Scan(&c.ID, &c.AccountID, &c.RepoName, &c.SHA, &c.Message, &c.CommittedAt); err != nil {
			return nil, err
		}
		commits = append(commits, c)
	}
	return commits, rows.Err()
}

func (r *CommitRepository) CountByAccount(since time.Time) (map[int64]int, error) {
	rows, err := r.db.Query(`
		SELECT account_id, COUNT(*) as count
		FROM commits
		WHERE committed_at >= ?
		GROUP BY account_id
		ORDER BY count DESC
	`, since)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	counts := make(map[int64]int)
	for rows.Next() {
		var accountID int64
		var count int
		if err := rows.Scan(&accountID, &count); err != nil {
			return nil, err
		}
		counts[accountID] = count
	}
	return counts, rows.Err()
}
```

**Step 2: Create repos repository**

```go
// internal/activity/repos.go
package activity

import (
	"time"

	"github.com/julienpequegnot/ghmon/internal/database"
)

type Repo struct {
	ID          int64
	AccountID   int64
	Name        string
	FullName    string
	Description string
	Language    string
	Stars       int
	CreatedAt   time.Time
}

type RepoRepository struct {
	db *database.DB
}

func NewRepoRepository(db *database.DB) *RepoRepository {
	return &RepoRepository{db: db}
}

func (r *RepoRepository) Add(accountID int64, name, fullName, description, language string, stars int, createdAt time.Time) error {
	_, err := r.db.Exec(
		`INSERT OR IGNORE INTO repos (account_id, name, full_name, description, language, stars, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)`,
		accountID, name, fullName, description, language, stars, createdAt,
	)
	return err
}

func (r *RepoRepository) GetNewSince(since time.Time) ([]Repo, error) {
	rows, err := r.db.Query(`
		SELECT id, account_id, name, full_name, description, language, stars, created_at
		FROM repos
		WHERE created_at >= ?
		ORDER BY created_at DESC
	`, since)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var repos []Repo
	for rows.Next() {
		var repo Repo
		if err := rows.Scan(&repo.ID, &repo.AccountID, &repo.Name, &repo.FullName, &repo.Description, &repo.Language, &repo.Stars, &repo.CreatedAt); err != nil {
			return nil, err
		}
		repos = append(repos, repo)
	}
	return repos, rows.Err()
}
```

**Step 3: Create stars repository**

```go
// internal/activity/stars.go
package activity

import (
	"time"

	"github.com/julienpequegnot/ghmon/internal/database"
)

type Star struct {
	ID              int64
	AccountID       int64
	RepoFullName    string
	RepoDescription string
	RepoLanguage    string
	RepoStars       int
	StarredAt       time.Time
}

type StarRepository struct {
	db *database.DB
}

func NewStarRepository(db *database.DB) *StarRepository {
	return &StarRepository{db: db}
}

func (r *StarRepository) Add(accountID int64, repoFullName, description, language string, stars int, starredAt time.Time) error {
	_, err := r.db.Exec(
		`INSERT OR IGNORE INTO stars (account_id, repo_full_name, repo_description, repo_language, repo_stars, starred_at) VALUES (?, ?, ?, ?, ?, ?)`,
		accountID, repoFullName, description, language, stars, starredAt,
	)
	return err
}

func (r *StarRepository) GetSince(since time.Time) ([]Star, error) {
	rows, err := r.db.Query(`
		SELECT id, account_id, repo_full_name, repo_description, repo_language, repo_stars, starred_at
		FROM stars
		WHERE starred_at >= ?
		ORDER BY starred_at DESC
	`, since)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var stars []Star
	for rows.Next() {
		var s Star
		if err := rows.Scan(&s.ID, &s.AccountID, &s.RepoFullName, &s.RepoDescription, &s.RepoLanguage, &s.RepoStars, &s.StarredAt); err != nil {
			return nil, err
		}
		stars = append(stars, s)
	}
	return stars, rows.Err()
}

// GetTrendingRepos returns repos starred by multiple followed accounts
func (r *StarRepository) GetTrendingRepos(since time.Time, minStars int) ([]struct {
	RepoFullName string
	StarCount    int
	AccountIDs   []int64
}, error) {
	rows, err := r.db.Query(`
		SELECT repo_full_name, COUNT(*) as star_count, GROUP_CONCAT(account_id) as account_ids
		FROM stars
		WHERE starred_at >= ?
		GROUP BY repo_full_name
		HAVING star_count >= ?
		ORDER BY star_count DESC
	`, since, minStars)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var trending []struct {
		RepoFullName string
		StarCount    int
		AccountIDs   []int64
	}

	for rows.Next() {
		var item struct {
			RepoFullName string
			StarCount    int
			AccountIDs   []int64
		}
		var accountIDsStr string
		if err := rows.Scan(&item.RepoFullName, &item.StarCount, &accountIDsStr); err != nil {
			return nil, err
		}
		// Parse account IDs would go here if needed
		trending = append(trending, item)
	}

	return trending, rows.Err()
}
```

**Step 4: Commit**

```bash
cd /Users/julienpequegnot/Code/ghmon && git add . && git commit -m "feat: add activity repositories (commits, repos, stars)"
```

---

## Task 11: Fetch Command

**Files:**
- Create: `cmd/fetch.go`

**Step 1: Create fetch command**

```go
// cmd/fetch.go
package cmd

import (
	"fmt"
	"sync"
	"time"

	"github.com/julienpequegnot/ghmon/internal/account"
	"github.com/julienpequegnot/ghmon/internal/activity"
	"github.com/julienpequegnot/ghmon/internal/config"
	"github.com/julienpequegnot/ghmon/internal/database"
	"github.com/julienpequegnot/ghmon/internal/github"
	"github.com/spf13/cobra"
)

var fetchCmd = &cobra.Command{
	Use:   "fetch",
	Short: "Fetch activity from monitored accounts",
	Long:  `Downloads recent commits, new repos, and stars from all monitored accounts.`,
	RunE:  runFetch,
}

func init() {
	rootCmd.AddCommand(fetchCmd)
}

func runFetch(cmd *cobra.Command, args []string) error {
	cfg, err := config.Load()
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	if cfg.GitHub.Token == "" {
		return fmt.Errorf("GitHub token not set. Add your token to %s", config.ConfigPath())
	}

	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to open database: %w", err)
	}
	defer db.Close()

	accountRepo := account.NewRepository(db)
	accounts, err := accountRepo.List()
	if err != nil {
		return fmt.Errorf("failed to list accounts: %w", err)
	}

	if len(accounts) == 0 {
		fmt.Println("No accounts to fetch. Run 'ghmon sync' or 'ghmon add <username>' first.")
		return nil
	}

	client := github.NewClient(cfg.GitHub.Token)
	commitRepo := activity.NewCommitRepository(db)
	repoRepo := activity.NewRepoRepository(db)
	starRepo := activity.NewStarRepository(db)

	fmt.Printf("Fetching activity for %d accounts...\n\n", len(accounts))

	var wg sync.WaitGroup
	semaphore := make(chan struct{}, cfg.Fetch.Concurrency)

	var mu sync.Mutex
	totalCommits := 0
	totalRepos := 0
	totalStars := 0

	for _, acc := range accounts {
		wg.Add(1)
		go func(acc account.Account) {
			defer wg.Done()
			semaphore <- struct{}{}
			defer func() { <-semaphore }()

			commits, repos, stars := fetchAccountActivity(client, &acc, commitRepo, repoRepo, starRepo)

			mu.Lock()
			totalCommits += commits
			totalRepos += repos
			totalStars += stars
			mu.Unlock()

			accountRepo.UpdateLastFetched(acc.ID)

			fmt.Printf("  %s: %d commits, %d repos, %d stars\n", acc.Username, commits, repos, stars)
		}(acc)
	}

	wg.Wait()

	fmt.Printf("\nFetch complete: %d commits, %d new repos, %d stars\n", totalCommits, totalRepos, totalStars)
	fmt.Println("Run 'ghmon digest' to see the summary.")

	return nil
}

func fetchAccountActivity(
	client *github.Client,
	acc *account.Account,
	commitRepo *activity.CommitRepository,
	repoRepo *activity.RepoRepository,
	starRepo *activity.StarRepository,
) (commits, repos, stars int) {

	// Fetch events (commits)
	events, err := client.GetUserEvents(acc.Username)
	if err == nil {
		for _, event := range events {
			if event.Type == "PushEvent" {
				payload, err := github.ParsePushPayload(event.Payload)
				if err != nil {
					continue
				}
				for _, commit := range payload.Commits {
					if commitRepo.Add(acc.ID, event.Repo.Name, commit.SHA, commit.Message, event.CreatedAt) == nil {
						commits++
					}
				}
			}
		}
	}

	// Fetch repos
	userRepos, err := client.GetUserRepos(acc.Username)
	if err == nil {
		cutoff := time.Now().AddDate(0, 0, -90) // Last 90 days
		for _, repo := range userRepos {
			if repo.CreatedAt.After(cutoff) {
				if repoRepo.Add(acc.ID, repo.Name, repo.FullName, repo.Description, repo.Language, repo.Stars, repo.CreatedAt) == nil {
					repos++
				}
			}
		}
	}

	// Fetch starred repos
	starred, err := client.GetUserStarred(acc.Username)
	if err == nil {
		cutoff := time.Now().AddDate(0, 0, -90)
		for _, star := range starred {
			if star.StarredAt.After(cutoff) {
				if starRepo.Add(acc.ID, star.FullName, star.Description, star.Language, star.Stars, star.StarredAt) == nil {
					stars++
				}
			}
		}
	}

	return commits, repos, stars
}
```

**Step 2: Build and test**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go build -o ghmon . && ./ghmon fetch --help
```

Expected: Help message displays

**Step 3: Commit**

```bash
cd /Users/julienpequegnot/Code/ghmon && git add . && git commit -m "feat: add fetch command"
```

---

## Task 12: Digest Command

**Files:**
- Create: `cmd/digest.go`

**Step 1: Create digest command**

```go
// cmd/digest.go
package cmd

import (
	"fmt"
	"sort"
	"time"

	"github.com/charmbracelet/lipgloss"
	"github.com/julienpequegnot/ghmon/internal/account"
	"github.com/julienpequegnot/ghmon/internal/activity"
	"github.com/julienpequegnot/ghmon/internal/config"
	"github.com/julienpequegnot/ghmon/internal/database"
	"github.com/spf13/cobra"
)

var digestCmd = &cobra.Command{
	Use:   "digest",
	Short: "Show activity digest",
	Long:  `Displays a summary of recent activity from monitored accounts.`,
	RunE:  runDigest,
}

var (
	digestDays int
)

func init() {
	rootCmd.AddCommand(digestCmd)
	digestCmd.Flags().IntVar(&digestDays, "days", 7, "Number of days to include in digest")
}

func runDigest(cmd *cobra.Command, args []string) error {
	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to open database: %w", err)
	}
	defer db.Close()

	since := time.Now().AddDate(0, 0, -digestDays)
	endDate := time.Now()

	accountRepo := account.NewRepository(db)
	commitRepo := activity.NewCommitRepository(db)
	repoRepo := activity.NewRepoRepository(db)
	starRepo := activity.NewStarRepository(db)

	accounts, _ := accountRepo.List()
	accountMap := make(map[int64]*account.Account)
	for i := range accounts {
		accountMap[accounts[i].ID] = &accounts[i]
	}

	// Get data
	commitCounts, _ := commitRepo.CountByAccount(since)
	newRepos, _ := repoRepo.GetNewSince(since)
	recentStars, _ := starRepo.GetSince(since)

	// Styles
	titleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("205"))
	sectionStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("39"))
	userStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("39"))
	repoStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("214"))
	dimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))

	// Header
	fmt.Printf("\n%s (%s - %s)\n",
		titleStyle.Render("GITHUB DIGEST"),
		since.Format("Jan 2"),
		endDate.Format("Jan 2, 2006"))
	fmt.Println(lipgloss.NewStyle().Foreground(lipgloss.Color("240")).Render("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"))

	// Summary
	totalCommits := 0
	for _, c := range commitCounts {
		totalCommits += c
	}

	fmt.Printf("\nðŸ“Š Summary: %d accounts Â· %d commits Â· %d new repos Â· %d stars\n\n",
		len(accounts), totalCommits, len(newRepos), len(recentStars))

	// Most Active
	if len(commitCounts) > 0 {
		fmt.Printf("%s\n", sectionStyle.Render("ðŸ”¥ Most Active"))

		type accountCommits struct {
			username string
			count    int
		}
		var sorted []accountCommits
		for accID, count := range commitCounts {
			if acc, ok := accountMap[accID]; ok {
				sorted = append(sorted, accountCommits{acc.Username, count})
			}
		}
		sort.Slice(sorted, func(i, j int) bool {
			return sorted[i].count > sorted[j].count
		})

		limit := 5
		if len(sorted) < limit {
			limit = len(sorted)
		}
		for i := 0; i < limit; i++ {
			fmt.Printf("  %-20s %d commits\n",
				userStyle.Render(sorted[i].username),
				sorted[i].count)
		}
		fmt.Println()
	}

	// New Repositories
	if len(newRepos) > 0 {
		fmt.Printf("%s\n", sectionStyle.Render("ðŸ†• New Repositories"))

		limit := 5
		if len(newRepos) < limit {
			limit = len(newRepos)
		}
		for i := 0; i < limit; i++ {
			repo := newRepos[i]
			desc := repo.Description
			if len(desc) > 50 {
				desc = desc[:47] + "..."
			}
			if desc == "" {
				desc = "(no description)"
			}
			fmt.Printf("  %s\n", repoStyle.Render(repo.FullName))
			fmt.Printf("    %s\n", dimStyle.Render(desc))
		}
		fmt.Println()
	}

	// Recent Stars (trending)
	if len(recentStars) > 0 {
		fmt.Printf("%s\n", sectionStyle.Render("â­ Recent Stars"))

		// Group stars by repo
		starCounts := make(map[string][]string)
		for _, s := range recentStars {
			if acc, ok := accountMap[s.AccountID]; ok {
				starCounts[s.RepoFullName] = append(starCounts[s.RepoFullName], acc.Username)
			}
		}

		// Sort by star count
		type repoStars struct {
			repo  string
			users []string
		}
		var sorted []repoStars
		for repo, users := range starCounts {
			sorted = append(sorted, repoStars{repo, users})
		}
		sort.Slice(sorted, func(i, j int) bool {
			return len(sorted[i].users) > len(sorted[j].users)
		})

		limit := 5
		if len(sorted) < limit {
			limit = len(sorted)
		}
		for i := 0; i < limit; i++ {
			item := sorted[i]
			fmt.Printf("  %s\n", repoStyle.Render(item.repo))
			if len(item.users) > 1 {
				fmt.Printf("    %s\n", dimStyle.Render(fmt.Sprintf("â˜… by %v", item.users)))
			} else {
				fmt.Printf("    %s\n", dimStyle.Render(fmt.Sprintf("â˜… by %s", item.users[0])))
			}
		}
		fmt.Println()
	}

	// Language breakdown
	languages := make(map[string]int)
	for _, repo := range newRepos {
		if repo.Language != "" {
			languages[repo.Language]++
		}
	}
	for _, star := range recentStars {
		if star.RepoLanguage != "" {
			languages[star.RepoLanguage]++
		}
	}

	if len(languages) > 0 {
		fmt.Printf("%s\n", sectionStyle.Render("ðŸ·ï¸ Languages"))

		type langCount struct {
			lang  string
			count int
		}
		var sorted []langCount
		total := 0
		for lang, count := range languages {
			sorted = append(sorted, langCount{lang, count})
			total += count
		}
		sort.Slice(sorted, func(i, j int) bool {
			return sorted[i].count > sorted[j].count
		})

		var parts []string
		limit := 5
		if len(sorted) < limit {
			limit = len(sorted)
		}
		for i := 0; i < limit; i++ {
			pct := float64(sorted[i].count) / float64(total) * 100
			parts = append(parts, fmt.Sprintf("%s (%.0f%%)", sorted[i].lang, pct))
		}
		fmt.Printf("  %s\n\n", dimStyle.Render(joinStrings(parts, " Â· ")))
	}

	return nil
}

func joinStrings(strs []string, sep string) string {
	if len(strs) == 0 {
		return ""
	}
	result := strs[0]
	for i := 1; i < len(strs); i++ {
		result += sep + strs[i]
	}
	return result
}
```

**Step 2: Build and test**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go build -o ghmon . && ./ghmon digest --help
```

Expected: Help message displays with --days flag

**Step 3: Commit**

```bash
cd /Users/julienpequegnot/Code/ghmon && git add . && git commit -m "feat: add digest command"
```

---

## Task 13: Show Command

**Files:**
- Create: `cmd/show.go`

**Step 1: Create show command**

```go
// cmd/show.go
package cmd

import (
	"fmt"
	"time"

	"github.com/charmbracelet/lipgloss"
	"github.com/julienpequegnot/ghmon/internal/account"
	"github.com/julienpequegnot/ghmon/internal/activity"
	"github.com/julienpequegnot/ghmon/internal/config"
	"github.com/julienpequegnot/ghmon/internal/database"
	"github.com/spf13/cobra"
)

var showCmd = &cobra.Command{
	Use:   "show <username>",
	Short: "Show activity for a specific user",
	Long:  `Displays detailed activity for a monitored GitHub user.`,
	Args:  cobra.ExactArgs(1),
	RunE:  runShow,
}

var showDays int

func init() {
	rootCmd.AddCommand(showCmd)
	showCmd.Flags().IntVar(&showDays, "days", 7, "Number of days to show")
}

func runShow(cmd *cobra.Command, args []string) error {
	username := args[0]

	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to open database: %w", err)
	}
	defer db.Close()

	accountRepo := account.NewRepository(db)
	acc, err := accountRepo.Get(username)
	if err != nil {
		return fmt.Errorf("account '%s' not found. Run 'ghmon add %s' first.", username, username)
	}

	since := time.Now().AddDate(0, 0, -showDays)

	commitRepo := activity.NewCommitRepository(db)
	repoRepo := activity.NewRepoRepository(db)
	starRepo := activity.NewStarRepository(db)

	commits, _ := commitRepo.GetForAccount(acc.ID, since)
	newRepos, _ := repoRepo.GetNewSince(since)
	stars, _ := starRepo.GetSince(since)

	// Filter repos and stars to this account
	var accountRepos []activity.Repo
	for _, r := range newRepos {
		if r.AccountID == acc.ID {
			accountRepos = append(accountRepos, r)
		}
	}
	var accountStars []activity.Star
	for _, s := range stars {
		if s.AccountID == acc.ID {
			accountStars = append(accountStars, s)
		}
	}

	// Styles
	titleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("205"))
	sectionStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("39"))
	repoStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("214"))
	dimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))
	shaStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))

	// Header
	name := acc.Name
	if name == "" {
		name = acc.Username
	}
	fmt.Printf("\n%s\n", titleStyle.Render(name))
	if acc.Bio != "" {
		fmt.Printf("%s\n", dimStyle.Render(acc.Bio))
	}
	fmt.Println(lipgloss.NewStyle().Foreground(lipgloss.Color("240")).Render("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"))

	// Summary
	fmt.Printf("\nðŸ“Š Last %d days: %d commits Â· %d new repos Â· %d stars\n\n",
		showDays, len(commits), len(accountRepos), len(accountStars))

	// Recent Commits
	if len(commits) > 0 {
		fmt.Printf("%s\n", sectionStyle.Render("ðŸ“ Recent Commits"))

		// Group by repo
		repoCommits := make(map[string][]activity.Commit)
		for _, c := range commits {
			repoCommits[c.RepoName] = append(repoCommits[c.RepoName], c)
		}

		for repo, repoCs := range repoCommits {
			fmt.Printf("  %s (%d commits)\n", repoStyle.Render(repo), len(repoCs))
			limit := 3
			if len(repoCs) < limit {
				limit = len(repoCs)
			}
			for i := 0; i < limit; i++ {
				c := repoCs[i]
				msg := c.Message
				if len(msg) > 50 {
					msg = msg[:47] + "..."
				}
				fmt.Printf("    %s %s\n", shaStyle.Render(c.SHA[:7]), msg)
			}
			if len(repoCs) > 3 {
				fmt.Printf("    %s\n", dimStyle.Render(fmt.Sprintf("... and %d more", len(repoCs)-3)))
			}
		}
		fmt.Println()
	}

	// New Repos
	if len(accountRepos) > 0 {
		fmt.Printf("%s\n", sectionStyle.Render("ðŸ†• New Repositories"))
		for _, repo := range accountRepos {
			fmt.Printf("  %s\n", repoStyle.Render(repo.FullName))
			if repo.Description != "" {
				desc := repo.Description
				if len(desc) > 60 {
					desc = desc[:57] + "..."
				}
				fmt.Printf("    %s\n", dimStyle.Render(desc))
			}
			if repo.Language != "" {
				fmt.Printf("    %s\n", dimStyle.Render(repo.Language))
			}
		}
		fmt.Println()
	}

	// Stars
	if len(accountStars) > 0 {
		fmt.Printf("%s\n", sectionStyle.Render("â­ Starred Repos"))
		limit := 10
		if len(accountStars) < limit {
			limit = len(accountStars)
		}
		for i := 0; i < limit; i++ {
			s := accountStars[i]
			fmt.Printf("  %s\n", repoStyle.Render(s.RepoFullName))
			if s.RepoLanguage != "" {
				fmt.Printf("    %s Â· %d â˜…\n", dimStyle.Render(s.RepoLanguage), s.RepoStars)
			}
		}
		if len(accountStars) > limit {
			fmt.Printf("  %s\n", dimStyle.Render(fmt.Sprintf("... and %d more", len(accountStars)-limit)))
		}
		fmt.Println()
	}

	return nil
}
```

**Step 2: Build and test**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go build -o ghmon . && ./ghmon show --help
```

Expected: Help message displays with --days flag

**Step 3: Commit**

```bash
cd /Users/julienpequegnot/Code/ghmon && git add . && git commit -m "feat: add show command"
```

---

## Task 14: Update README and Final Tests

**Files:**
- Modify: `README.md`

**Step 1: Run all tests**

Run:
```bash
cd /Users/julienpequegnot/Code/ghmon && go test ./... -v
```

Expected: All tests pass

**Step 2: Update README status**

Update Development Status section in README.md:
```markdown
### Phase 1 (MVP) - Complete
- [x] Project setup
- [x] init command
- [x] sync command
- [x] add/remove commands
- [x] accounts command
- [x] fetch command
- [x] digest command
- [x] show command
```

**Step 3: Final commit and push**

```bash
cd /Users/julienpequegnot/Code/ghmon && git add . && git commit -m "docs: mark Phase 1 MVP as complete"
cd /Users/julienpequegnot/Code/ghmon && git push
```

---

## Summary

**Phase 1 delivers:**
- Full CLI with init, sync, add, remove, accounts, fetch, digest, show commands
- GitHub API integration for following list, events, repos, stars
- SQLite storage for accounts and activity
- Styled terminal output with Lipgloss
- Configurable time windows for digests

**New commands:**
- `ghmon init` - Setup config and database
- `ghmon sync` - Import GitHub following list
- `ghmon add/remove` - Manual account management
- `ghmon accounts` - List monitored accounts
- `ghmon fetch` - Pull activity from GitHub
- `ghmon digest` - Show activity summary
- `ghmon show <user>` - User details

**Pipeline:**
```
sync â†’ fetch â†’ digest
  â†“      â†“       â†“
accounts â†’ activity â†’ summary
```
